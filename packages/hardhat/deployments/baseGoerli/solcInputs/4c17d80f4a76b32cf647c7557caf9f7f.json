{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @title Enum - Collection of enums\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    enum GrantStatus {\n        Created, // 0\n        Ongoing, // 1\n        Payed, // 2\n        Canceled //3\n    }\n}\n"
    },
    "contracts/GrantPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Enum.sol\";\nimport \"./SignatureDecoder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface GnosisSafe {\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (bool success);\n}\n\ncontract GrantPaymentModule {\n    // ----------------------------------------\n    //      Constants\n    // ----------------------------------------\n\n    IERC20 public token; // Declare the USDC token contract\n\n    string public constant NAME = \"GRANTS Module\";\n    string public constant VERSION = \"0.1.0\";\n    bytes32 public constant GRANT_TRANSFER_TYPEHASH =\n        keccak256(\"Grant Transfer\");\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"Domain Separator\");\n\n    address public owner; // contract owner/admin\n    address tokenAddress;\n\n    // do we need Safe -> RefUID -> Grants ??\n    // RefUID -> Grants ??\n    mapping(string => Grant) public grants;\n    mapping(address => bool) public approvedDelegates;\n\n    struct Grant {\n        address delegate;\n        address grantee;\n        uint96 amount;\n        uint96 distributedAmount;\n        uint96 milestoneAmount;\n        uint96 reachedMilestoneAmount;\n        string grantRefID;\n        Enum.GrantStatus status;\n        uint16 nonce; // You mentioned you're unsure about the nonce. For now, I've added it.\n    }\n\n    // ----------------------------------------\n    //      Events\n    // ----------------------------------------\n\n    event GrantCreated(\n        string grantRefID,\n        address delegate,\n        uint96 amount,\n        uint96 milestoneAmount\n    );\n    event GrantUpdated(\n        string grantRefID,\n        uint96 distributedAmount,\n        uint96 reachedMilestoneAmount\n    );\n    event GrantPayed(string grantRefID, Enum.GrantStatus status);\n    event GrantCanceled(string grantRefID, Enum.GrantStatus status);\n    event ExecuteGrantTransfer(\n        address delegate,\n        address grantee,\n        uint96 distributedAmount,\n        uint96 amount,\n        uint96 milestoneAmount,\n        uint96 reachedMilestoneAmount,\n        string grantRefID,\n        Enum.GrantStatus status,\n        uint16 nonce\n    );\n\n    // ----------------------------------------\n    //      Modifiers\n    // ----------------------------------------\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized: must be owner\");\n        _;\n    }\n\n    modifier onlyApprovedDelegate(address _delegate) {\n        require(approvedDelegates[_delegate], \"Not an approved delegate\");\n        _;\n    }\n\n    modifier onlyDelegateOrOwner(address _delegate, string memory _grantRefID) {\n        require(\n            msg.sender == grants[_grantRefID].delegate || msg.sender == owner,\n            \"Not authorized: must be current delegate or owner\"\n        );\n        _;\n    }\n\n    constructor(address _tokenAddress) {\n        owner = msg.sender; // Set the contract deployer as the initial owner.\n        tokenAddress = _tokenAddress;\n        token = IERC20(tokenAddress); // Initialize the USDC token contract\n    }\n\n    // do we need this????\n    function addDelegates(address[] memory _delegates) public onlyOwner {\n        for (uint i = 0; i < _delegates.length; i++) {\n            approvedDelegates[_delegates[i]] = true;\n        }\n    }\n\n    function setGrant(\n        address _granteeAddress,\n        address _delegate,\n        uint96 _amount,\n        uint96 _milestoneAmount,\n        string memory _grantRefID\n    ) public {\n        grants[_grantRefID] = Grant({\n            delegate: _delegate,\n            grantee: _granteeAddress,\n            amount: _amount,\n            distributedAmount: 0,\n            milestoneAmount: _milestoneAmount,\n            reachedMilestoneAmount: 0,\n            grantRefID: _grantRefID,\n            status: Enum.GrantStatus.Created,\n            nonce: 0\n        });\n\n        emit GrantCreated(_grantRefID, _delegate, _amount, _milestoneAmount);\n    }\n\n    function getGrant(\n        string memory _grantRefID\n    ) public view returns (Grant memory) {\n        return grants[_grantRefID];\n    }\n\n    function updateGrantDelegate(\n        string memory _grantRefID,\n        address _newDelegate\n    ) public onlyDelegateOrOwner(msg.sender, _grantRefID) {\n        require(\n            approvedDelegates[_newDelegate],\n            \"New delegate is not approved\"\n        );\n\n        grants[_grantRefID].delegate = _newDelegate;\n    }\n\n    // TODO: payable needs to be removed. as payment should work with the set token\n    function updateGrant(\n        string memory _grantRefID,\n        uint96 _currentMilestone,\n        address _delegate\n    ) public payable {\n        // Get current state\n        Grant memory grant = grants[_grantRefID];\n        // if a new milestone is approved, a matching amount will be payed to the grantee\n        if (grant.reachedMilestoneAmount != _currentMilestone) {\n            grant.reachedMilestoneAmount = _currentMilestone;\n\n            executeGrantTransfer(_grantRefID);\n            if (grant.milestoneAmount == _currentMilestone) {\n                grant.status = Enum.GrantStatus.Payed;\n                emit GrantPayed(_grantRefID, grant.status);\n            }\n            if (grant.milestoneAmount != _currentMilestone) {\n                grant.status = Enum.GrantStatus.Ongoing;\n            }\n        }\n        if (grant.delegate != _delegate) {\n            grant.delegate = _delegate;\n        }\n    }\n\n    function executeGrantTransfer(string memory _grantRefID) internal {\n        // Get current state\n        Grant memory grant = grants[_grantRefID];\n\n        // Calculate the amount to transfer for the reached milestone.\n        uint96 transferAmount = grant.amount / grant.milestoneAmount;\n\n        // Ensure the contract has enough funds and the grant has not exceeded its limit.\n        require(\n            grant.distributedAmount + transferAmount <= grant.amount,\n            \"Transfer exceeds grant limit\"\n        );\n\n        // Transfer the funds. should be transferAmount, when payment with set token is enabled\n        token.transferFrom(msg.sender, grant.grantee, msg.value);\n\n        grant.nonce = grant.nonce + 1;\n\n        // payable(_granteeAddress).transfer(transferAmount);\n\n        // Update the distributed amount for the grant.\n        grant.distributedAmount += transferAmount;\n        emit ExecuteGrantTransfer(\n            grant.delegate,\n            grant.grantee,\n            grant.milestoneAmount,\n            grant.reachedMilestoneAmount,\n            grant.amount,\n            grant.distributedAmount,\n            grant.grantRefID,\n            grant.status,\n            grant.nonce - 1\n        );\n    }\n\n    function cancelGrant(string memory _grantRefID) public onlyOwner {\n        Grant memory grant = grants[_grantRefID];\n\n        grant.status = Enum.GrantStatus.Canceled;\n        emit GrantCanceled(_grantRefID, grant.status);\n    }\n}\n"
    },
    "contracts/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    \n    /// @dev Recovers address who signed the message\n    /// @param messageHash operation ethereum signed message hash\n    /// @param messageSignature message `txHash` signature\n    /// @param pos which signature to read\n    function recoverKey (\n        bytes32 messageHash,\n        bytes memory messageSignature,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignature, pos);\n        return ecrecover(messageHash, v, r, s);\n    }\n\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}